const express = require("express");
const bodyParser = require("body-parser");
const { exec } = require("child_process");
const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const os = require("os");
const rateLimit = require("express-rate-limit");

const app = express();
const port = 3000;

app.enable("trust proxy"); // Ensure req.ip works behind proxies/load balancers (e.g. Cloud Run)
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, "public")));

const getFileHash = (req) => {
  const ip = req.ip || req.connection.remoteAddress || "unknown";
  return crypto.createHash("md5").update(ip).digest("hex");
};

// Cleanup stale files (safety net for crashed processes)
const CLEANUP_AGE = 10 * 60 * 1000; // 10 minutes

const cleanupStaleFiles = () => {
  const tmpDir = os.tmpdir();
  const generatedDir = path.join(tmpDir, "generated");
  const now = Date.now();

  // 1. Clean .rox files in tmpDir
  fs.readdir(tmpDir, (err, files) => {
    if (err) return; // Ignore errors (e.g. permission)

    files.forEach((file) => {
      if (file.startsWith("temp_") && file.endsWith(".rox")) {
        const filePath = path.join(tmpDir, file);
        fs.stat(filePath, (err, stats) => {
          if (!err && now - stats.mtimeMs > CLEANUP_AGE) {
            fs.unlink(filePath, () => {});
          }
        });
      }
    });
  });

  // 2. Clean artifacts in generatedDir
  fs.readdir(generatedDir, (err, files) => {
    if (err) return; // generated dir might not exist yet

    files.forEach((file) => {
      if (file.startsWith("temp_")) {
        const filePath = path.join(generatedDir, file);
        fs.stat(filePath, (err, stats) => {
          if (!err && now - stats.mtimeMs > CLEANUP_AGE) {
            fs.unlink(filePath, () => {});
          }
        });
      }
    });
  });
};

// Run cleanup every 10 minutes
setInterval(cleanupStaleFiles, CLEANUP_AGE);

// Rate Limiting
const limiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 20, // Limit each IP to 20 requests per `window` (here, per 1 minute)
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  message: { error: "Too many requests. Please wait a moment." },
});

app.post("/run", limiter, (req, res) => {
  const code = req.body.code;
  const hash = getFileHash(req);
  const tempFileName = `temp_${hash}.rox`;
  const tempFile = path.resolve(__dirname, `../${tempFileName}`);

  // Artifacts generated by the compiler
  const generatedBase = `temp_${hash}`;
  const generatedCc = path.resolve(
    __dirname,
    `../generated/${generatedBase}.cc`,
  );
  const generatedBin = path.resolve(__dirname, `../generated/${generatedBase}`);

  fs.writeFile(tempFile, code, (err) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ output: "Error writing temp file." });
    }

    const roxPath = path.resolve(__dirname, "../rox");
    const cmd = `${roxPath} run ${tempFile}`;

    exec(
      cmd,
      { cwd: path.resolve(__dirname, "..") },
      (error, stdout, stderr) => {
        // Cleanup all temporary files
        const filesToDelete = [tempFile, generatedCc, generatedBin];
        filesToDelete.forEach((f) => fs.unlink(f, () => {}));

        // Separate build logs from program output
        const lines = stdout.split("\n");
        const logs = [];
        const outputLines = [];

        for (const line of lines) {
          if (line.startsWith("Generated ") || line.startsWith("Compiled ")) {
            logs.push(line);
          } else {
            outputLines.push(line);
          }
        }

        if (error) {
          return res.json({
            output: stderr || outputLines.join("\n").trim() || error.message,
            logs: logs.join("\n"),
          });
        }

        res.json({
          output: outputLines.join("\n").trim(),
          logs: logs.join("\n"),
        });
      },
    );
  });
});

app.post("/format", limiter, (req, res) => {
  const code = req.body.code;
  const hash = getFileHash(req);
  const tempFile = path.resolve(__dirname, `../temp_format_${hash}.rox`);

  fs.writeFile(tempFile, code, (err) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ error: "Error writing temp file." });
    }

    const roxPath = path.resolve(__dirname, "../rox");
    const cmd = `${roxPath} format ${tempFile}`;

    exec(
      cmd,
      { cwd: path.resolve(__dirname, "..") },
      (error, stdout, stderr) => {
        if (error) {
          fs.unlink(tempFile, () => {});
          return res.status(500).json({ error: stderr || error.message });
        }

        fs.readFile(tempFile, "utf8", (readErr, data) => {
          fs.unlink(tempFile, () => {});
          if (readErr) {
            console.error(readErr);
            return res
              .status(500)
              .json({ error: "Error reading formatted file." });
          }
          res.json({ formatted: data });
        });
      },
    );
  });
});

app.listen(port, () => {
  console.log(`ROX Playground running at http://localhost:${port}`);
});
